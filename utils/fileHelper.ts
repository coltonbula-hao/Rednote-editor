export const fileToBase64 = (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      const result = reader.result as string;
      // Remove the Data URL prefix (e.g., "data:application/pdf;base64,")
      const base64 = result.split(',')[1];
      resolve(base64);
    };
    reader.onerror = (error) => reject(error);
  });
};

export const parseGeminiResponse = (text: string) => {
  // We will instruct Gemini to use specific separators
  const blogMatch = text.match(/\[Part 1 博文 Markdown\]([\s\S]*?)(\[Part 2|$)/i);
  const xhsTitleMatch = text.match(/\[Part 2 小红书标题([\s\S]*?)(\[Part 3|$)/i);
  const xhsContentMatch = text.match(/\[Part 3 小红书图文内容\]([\s\S]*?)(\[Part 4|$)/i);
  const infoMatch = text.match(/\[Part 4 信息图提示词\]([\s\S]*?$)/i);

  return {
    blogPost: blogMatch ? blogMatch[1].trim() : '',
    xhsTitles: xhsTitleMatch ? xhsTitleMatch[1].trim() : '',
    xhsContent: xhsContentMatch ? xhsContentMatch[1].trim() : '',
    infographicPrompts: infoMatch ? infoMatch[1].trim() : '',
  };
};

export const extractImagePrompts = (text: string): string[] => {
  // Matches "Image 1: content" up to "Image 2:" or end of string
  const prompts: string[] = [];
  const lines = text.split('\n');
  
  lines.forEach(line => {
    // Basic matching for lines starting with "Image X:"
    const match = line.match(/^Image\s+\d+\s*:(.+)$/i);
    if (match) {
      prompts.push(match[1].trim());
    }
  });
  
  return prompts;
};

// YouTube Extraction Logic
export const extractYoutubeId = (url: string): string | null => {
  const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
  const match = url.match(regExp);
  return (match && match[2].length === 11) ? match[2] : null;
};

export const fetchYoutubeTranscript = async (videoId: string): Promise<string | null> => {
  try {
    // Use Piped API (privacy-friendly YouTube frontend) to get metadata
    const response = await fetch(`https://pipedapi.kavin.rocks/streams/${videoId}`);
    if (!response.ok) throw new Error('Video not found');
    const data = await response.json();
    
    const subtitles = data.subtitles;
    if (!subtitles || subtitles.length === 0) return null;

    // Priority: Manual Chinese -> Auto Chinese -> Manual English -> Auto English -> First available
    const findSub = (lang: string, auto: boolean) => 
      subtitles.find((s: any) => s.code && s.code.startsWith(lang) && s.autoGenerated === auto);

    const selectedSub = 
      findSub('zh', false) || 
      findSub('zh', true) || 
      findSub('en', false) || 
      findSub('en', true) || 
      subtitles[0];

    if (!selectedSub) return null;

    // Fetch the VTT content
    const subResponse = await fetch(selectedSub.url);
    const vttText = await subResponse.text();

    // Parse VTT to clean text
    // Remove WEBVTT header, timestamps, and metadata
    const lines = vttText.split('\n');
    let cleanText = '';
    const seenText = new Set<string>(); // Dedup repeated lines common in VTT

    lines.forEach(line => {
      line = line.trim();
      // Skip empty lines, 'WEBVTT', timestamps (00:00:00.000 --> ...)
      if (!line || line === 'WEBVTT' || line.includes('-->')) return;
      
      // Remove HTML-like tags if any
      const text = line.replace(/<[^>]*>/g, '');
      
      // Simple deduplication for scrolling captions
      if (!seenText.has(text)) {
        cleanText += text + ' ';
        seenText.add(text);
      }
    });

    return `[YouTube Video Transcript]\nTitle: ${data.title}\n\n${cleanText.trim()}`;
  } catch (error) {
    console.error('Failed to fetch transcript:', error);
    return null;
  }
};